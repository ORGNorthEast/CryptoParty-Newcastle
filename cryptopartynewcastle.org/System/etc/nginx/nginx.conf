#   ____                  _        ____            _
#  / ___|_ __ _   _ _ __ | |_ ___ |  _ \ __ _ _ __| |_ _   _
# | |   | '__| | | | '_ \| __/ _ \| |_) / _` | '__| __| | | |
# | |___| |  | |_| | |_) | || (_) |  __/ (_| | |  | |_| |_| |
#  \____|_|   \__, | .__/ \__\___/|_|   \__,_|_|   \__|\__, |
#             |___/|_|                                 |___/
#        _   _                            _   _
#       | \ | | _____      _____ __ _ ___| |_| | ___
#       |  \| |/ _ \ \ /\ / / __/ _` / __| __| |/ _ \
#       | |\  |  __/\ V  V / (_| (_| \__ \ |_| |  __/
#       |_| \_|\___| \_/\_/ \___\__,_|___/\__|_|\___|
#

# "One ought to design systems under the assumption that the enemy will immediately gain full familiarity with them." -- Shannon's Maxim

# Nginx webserver config. Made public for anyone to copy/modify and learn from.
# If you spot any misconfiguration in this file - or anything you think we could be
# doing better - please let our admin know at: alex@alexhaydock.co.uk. Thanks!

user                                    www-data; # This user is named 'nginx' on Red Hat family distributions like CentOS.
worker_processes			1;
worker_priority				15; # Equal to "nice=15". This is to prevent attacks on nginx from bringing down the machine (and/or being used as timing attacks).
error_log				/var/log/nginx/error.log;
pid					/run/nginx.pid;

events {
	worker_connections		512; # Number of connections per worker process
}

http {
# Keep access logs, but anonymise IPs by only keeping the first three octets.
	map $remote_addr $ip_anonym1 { default 0.0.0; "~(?P<ip>(\d+)\.(\d+)\.(\d+))\.\d+" $ip; "~(?P<ip>[^:]+:[^:]+):" $ip; } # Grab part of the IP we want to have in the log
	map $remote_addr $ip_anonym2 { default .0; "~(?P<ip>(\d+)\.(\d+)\.(\d+))\.\d+" .0; "~(?P<ip>[^:]+:[^:]+):" ::; } # Return the part that symbolises the anonymised part
	map $ip_anonym1$ip_anonym2 $ip_anonymized { default 0.0.0.0; "~(?P<ip>.*)" $ip; } # Map them back together again
	log_format anonymised '$ip_anonymized - $remote_user [$time_local] "$request" $status $body_bytes_sent "$http_referer" "$http_user_agent"'; # Define the IP-'anonymised' logging format
	access_log /var/log/nginx/access.log anonymised; # Use IP-'anonymised' log format for the access log

	# Timeouts to ensure we do not keep connections open longer then necessary to reduce resource usage and deny Slowloris type attacks.
	client_body_timeout		4s; # maximum time between packets the client can pause when sending nginx any data
	client_header_timeout		4s; # maximum time the client has to send the entire header to nginx
	keepalive_timeout		75s; # timeout which a single keep-alive client connection will stay open
	send_timeout			24s; # maximum time between packets nginx is allowed to pause when sending the client data
#	spdy_keepalive_timeout		123s; # inactivity timeout after which the SPDY connection is closed
#	spdy_recv_timeout		4s; # timeout if nginx is currently expecting data from the client but nothing arrives

	# Various options
	charset				utf-8;
	client_max_body_size		32M; # I can't see any reason why a client would ever need to be submitting content larger than this in one go for our server.
	default_type			application/octet-stream;
	gzip				on;
	# gzip_static			off; # If we've precompressed content with an external script. We'd need ".html.gz" files, for example, existing in our directory to use this.
	gzip_proxied			any; # Allows compressed responses for any request even from proxies
	ignore_invalid_headers		on;
	include				/etc/nginx/mime.types;
	index				index.html.en index.html; # Ensure that index.html.en is added to support the structure used in the TorProject mirror site
	keepalive_requests		50;  # Number of requests per connection (does not affect SPDY)
	keepalive_disable		none; # Allow all browsers to use keepalive connections
	max_ranges			1; # Only allow a single range header - for resumed downloads, and to stop large range header DoS attacks
	open_file_cache			max=1000 inactive=2h;
	open_file_cache_errors		on;
	open_file_cache_min_uses	1;
	open_file_cache_valid		1h;
	output_buffers			1 512; # Use one 512k chunk output buffer (only if sendfile is off)
	read_ahead			512K; # Kernel read head set to the output_buffers
	recursive_error_pages		on;
	reset_timedout_connection	on; # Reset timed out connections to free RAM
	sendfile			on;  # On for decent direct disk I/O
	server_tokens			off; # Version number in error pages
	server_name_in_redirect		off; # If off, nginx will use the requested Host header
	source_charset			utf-8; # Same value as "charset"
	tcp_nodelay			on; # Nagle buffering algorithm, used for keepalive only
	tcp_nopush			off;

	# Redirect all HTTP requests to HTTPS
	server {
		listen			80 default; # listen on HTTP port for ipv4
		listen			[::]:80 default; # listen on HTTP port for ipv6
		server_name		cryptopartynewcastle.org www.cryptopartynewcastle.org beta.cryptopartynewcastle.org;
		rewrite			^ https://$server_name$request_uri? permanent;
	}

	# Main site HTTPS Block
	server {
		listen			443 ssl http2; # Listen on SSL port for IPv4 with HTTP/2
		listen			[::]:443 ssl http2; # Listen on SSL port for IPv6 with HTTP/2
		server_name		cryptopartynewcastle.org www.cryptopartynewcastle.org;
		root			/usr/share/nginx/html/cryptopartynewcastle/www;

		# Manage standard headers
		add_header		Strict-Transport-Security "max-age=63072000; includeSubDomains; preload"; # Enable HSTS with a 2-year timeout
		add_header		X-Frame-Options "DENY"; # Disallow the site from being loaded in an IFRAME. Works to prevent clickjacking attempts
		add_header		X-Content-Type-Options nosniff;
		add_header		X-XSS-Protection "1; mode=block";
		add_header		Cache-Control "public";

		# Manage CSP (http://www.html5rocks.com/en/tutorials/security/content-security-policy/)
#		add_header		Content-Security-Policy "default-src 'self';";

                # Enable HTTP Public Key Pinning header (Here be demons!)
                ## Pin1 is for the CA cert of 'Let's Encrypt Authority X3', and Pin2 is for 'Gandi Standard SSL CA 2'. Maximum pin age is set to 60 days.
                ## I'm pinning CA certs here instead of my leaf cert because the leaf is regenerated every 90 days with LetsEncrypt and this could end up becoming a huge pain.
                ## At least with these pins it means that no weird CAs can go issuing certs for my domain and only LetsEncrypt/Gandi can do it.
		## This setup means that if LetsEncrypt disappears or I screw up somehow, I can at least go and buy a Gandi cert to get myself out of the mess.
                ## To avoid needing to extract certs and hash them with OpenSSL, remember that SSLLabs' testing tool helpfully shows the required sha256 hashes for pasting straight into this pinning line.
		## This line uses 'always' to ensure that Nginx will always send this header, regardless of the response code.
                add_header public-key-pins 'pin-sha256="YLh1dUR9y6Kja30RrAn7JKnbQG/uEtLMkBgFF2Fuihg="; pin-sha256="WGJkyYjx1QMdMe0UqlyOKXtydPDVrk7sl2fV+nNm1r4="; max-age=5184000; includeSubDomains' always;

		# Basic SSL options
		ssl			on;
		ssl_prefer_server_ciphers	on; # Ensure that my cipher preference list is used and not the client's
		ssl_session_cache	shared:SSL:5m; # Allow reuse of sessions so client doesn't need full handshake for each request. (https://vincent.bernat.im/en/blog/2011-ssl-session-reuse-rfc5077.html)
		ssl_session_timeout	5m; # But also timeout sessions after 5min to ensure forward secrecy.
		ssl_session_tickets	off;
#		ssl_stapling		on; # Must be disabled when using BoringSSL. (https://www.imperialviolet.org/2014/04/19/revchecking.html)
#		ssl_stapling_verify	on; # Must be disabled when using BoringSSL. (https://www.imperialviolet.org/2014/04/19/revchecking.html)

		# Site now uses LetsEncrypt as its default CA
		## Generate new 384-bit ECDSA cert (better than using a 4096-bit RSA cert because it forces us to use ECDHE) with the instructions at:
		##    https://github.com/ORGNorthEast/CryptoParty-Newcastle/tree/master/cryptopartynewcastle.org/LetsEncrypt/
		ssl_certificate		/usr/share/nginx/keys/ecdsa-chain.pem;
		ssl_certificate_key	/usr/share/nginx/keys/privkey-p384.pem;

		# Enable only highest-strength protocol(s)
		ssl_protocols		TLSv1.2; # Don't bother supporting TLS v1.0 and v1.1

		# Enable only highest strength ECDSA ciphers (Google Chrome's preferred order with 128bit before 256bit because it's faster and less susceptible to timing attacks)
		##ssl_ciphers		'ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384'; # OpenSSL
		ssl_ciphers		[ECDHE-ECDSA-CHACHA20-POLY1305|ECDHE-ECDSA-AES128-GCM-SHA256]:[ECDHE-ECDSA-AES256-GCM-SHA384]; # BoringSSL (https://github.com/ajhaydock/BoringNginx)

		# Specify a curve to use for the Elliptic Curve Diffie-Hellman Exchange (ECDHE) ciphers
		## So far only Chromium supports X25519, meaning we still need to enable some NIST curves to support other clients, but this ought to work for now.
		ssl_ecdh_curve		secp384r1;

		# Main location block
		location / {
		}

		location /.well-known {
			# LetsEncrypt client uses this directory to serve some files during the certificate generation process to prove we own the domain
			# This directive ensures that requests for this dir are served by Nginx itself and aren't passed back to any PHP processor or other reverse proxy
			root			/usr/share/nginx/letsencrypt;
		}

		# Special location blocks
		location /favicon.ico { return 204; } # Serve HTTP 204 for favicon because I can't be bothered to make one, but don't want to see it turn up in the error log
		location ~ \.htaccess { return 418; }
		location /.git { return 418; }
		location /wp-admin { return 418; }
		location /wp-login { return 418; }
		location /install.php { return 418; }
		location /admin { return 418; }

		# Error pages
		error_page 404 /404/; location = /404/ { }
		error_page 418 /418/; location = /418/ { }
		error_page 500 /500/; location = /500/ { }
		error_page 502 /502/; location = /502/ { }
		error_page 503 /503/; location = /503/ { }
		error_page 504 /504/; location = /504/ { }
	}

	# Beta site HTTPS Block
	server {
		listen			443 ssl http2; # Listen on SSL port for IPv4 with HTTP/2
		listen			[::]:443 ssl http2; # Listen on SSL port for IPv6 with HTTP/2
		server_name		beta.cryptopartynewcastle.org;
		root			/usr/share/nginx/html/cryptopartynewcastle/beta;

		# Manage standard headers
		add_header		Strict-Transport-Security "max-age=63072000; includeSubDomains; preload"; # Enable HSTS with a 2-year timeout
		add_header		X-Frame-Options "DENY"; # Disallow the site from being loaded in an IFRAME. Works to prevent clickjacking attempts
		add_header		X-Content-Type-Options nosniff;
		add_header		X-XSS-Protection "1; mode=block";
		add_header		Cache-Control "public";

		# Manage CSP (http://www.html5rocks.com/en/tutorials/security/content-security-policy/)
#		add_header		Content-Security-Policy "default-src 'self';";

                # Enable HTTP Public Key Pinning header (Here be demons!)
                ## Pin1 is for the CA cert of 'Let's Encrypt Authority X3', and Pin2 is for 'Gandi Standard SSL CA 2'. Maximum pin age is set to 60 days.
                ## I'm pinning CA certs here instead of my leaf cert because the leaf is regenerated every 90 days with LetsEncrypt and this could end up becoming a huge pain.
                ## At least with these pins it means that no weird CAs can go issuing certs for my domain and only LetsEncrypt/Gandi can do it.
		## This setup means that if LetsEncrypt disappears or I screw up somehow, I can at least go and buy a Gandi cert to get myself out of the mess.
                ## To avoid needing to extract certs and hash them with OpenSSL, remember that SSLLabs' testing tool helpfully shows the required sha256 hashes for pasting straight into this pinning line.
		## This line uses 'always' to ensure that Nginx will always send this header, regardless of the response code.
                add_header public-key-pins 'pin-sha256="YLh1dUR9y6Kja30RrAn7JKnbQG/uEtLMkBgFF2Fuihg="; pin-sha256="WGJkyYjx1QMdMe0UqlyOKXtydPDVrk7sl2fV+nNm1r4="; max-age=5184000; includeSubDomains' always;

		# Basic SSL options
		ssl			on;
		ssl_prefer_server_ciphers	on; # Ensure that my cipher preference list is used and not the client's
		ssl_session_cache	shared:SSL:5m; # Allow reuse of sessions so client doesn't need full handshake for each request. (https://vincent.bernat.im/en/blog/2011-ssl-session-reuse-rfc5077.html)
		ssl_session_timeout	5m; # But also timeout sessions after 5min to ensure forward secrecy.
		ssl_session_tickets	off;
#		ssl_stapling		on; # Must be disabled when using BoringSSL. (https://www.imperialviolet.org/2014/04/19/revchecking.html)
#		ssl_stapling_verify	on; # Must be disabled when using BoringSSL. (https://www.imperialviolet.org/2014/04/19/revchecking.html)

		# Site now uses LetsEncrypt as its default CA
		## Generate new 384-bit ECDSA cert (better than using a 4096-bit RSA cert because it forces us to use ECDHE) with the instructions at:
		##    https://github.com/ORGNorthEast/CryptoParty-Newcastle/tree/master/cryptopartynewcastle.org/LetsEncrypt/
		ssl_certificate		/usr/share/nginx/keys/ecdsa-chain.pem;
		ssl_certificate_key	/usr/share/nginx/keys/privkey-p384.pem;

		# Enable only highest-strength protocol(s)
		ssl_protocols		TLSv1.2; # Don't bother supporting TLS v1.0 and v1.1

		# Enable only highest strength ECDSA ciphers (Google Chrome's preferred order with 128bit before 256bit because it's faster and less susceptible to timing attacks)
		##ssl_ciphers		'ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384'; # OpenSSL
		ssl_ciphers		[ECDHE-ECDSA-CHACHA20-POLY1305|ECDHE-ECDSA-AES128-GCM-SHA256]:[ECDHE-ECDSA-AES256-GCM-SHA384]; # BoringSSL (https://github.com/ajhaydock/BoringNginx)

		# Specify a curve to use for the Elliptic Curve Diffie-Hellman Exchange (ECDHE) ciphers
		## So far only Chromium supports X25519, meaning we still need to enable some NIST curves to support other clients, but this ought to work for now.
		ssl_ecdh_curve		secp384r1;

		# Main location block
		location / {
		}

		location /.well-known {
			# LetsEncrypt client uses this directory to serve some files during the certificate generation process to prove we own the domain
			# This directive ensures that requests for this dir are served by Nginx itself and aren't passed back to any PHP processor or other reverse proxy
			root			/usr/share/nginx/letsencrypt;
		}

		# Special location blocks
		location /favicon.ico { return 204; } # Serve HTTP 204 for favicon because I can't be bothered to make one, but don't want to see it turn up in the error log
		location ~ \.htaccess { return 418; }
		location /.git { return 418; }
		location /wp-admin { return 418; }
		location /wp-login { return 418; }
		location /install.php { return 418; }
		location /admin { return 418; }

		# Error pages
		error_page 404 /404/; location = /404/ { }
		error_page 418 /418/; location = /418/ { }
		error_page 500 /500/; location = /500/ { }
		error_page 502 /502/; location = /502/ { }
		error_page 503 /503/; location = /503/ { }
		error_page 504 /504/; location = /504/ { }
	}

	# Accept HTTP connections, but only for .onion address and when coming from localhost
	server {
		listen			8080; # Listen locally on :8080, because we're already using :80 for the simple redirect to HTTPS. HTTP/2 doesn't work here yet and just confuses the Tor Browser.
		server_name		nclcrypto2bfuejv.onion;
		root			/usr/share/nginx/html/cryptopartynewcastle/www;

		allow			127.0.0.1;
		deny			all;

		# Manage standard headers (these should at least be enough to satisfy OnionScan)
		add_header		X-Frame-Options "DENY"; # Disallow the site from being loaded in an IFRAME. Works to prevent clickjacking attempts
		add_header		X-Content-Type-Options nosniff;
		add_header		X-XSS-Protection "1; mode=block";
		add_header		Cache-Control "public";

		# Manage CSP (http://www.html5rocks.com/en/tutorials/security/content-security-policy/)
#		add_header		Content-Security-Policy "default-src 'self';";

		# Special location blocks
		location /favicon.ico { return 204; } # Serve HTTP 204 for favicon because I can't be bothered to make one, but don't want to see it turn up in the error log
		location ~ \.htaccess { return 418; }
		location /.git { return 418; }
		location /wp-admin { return 418; }
		location /wp-login { return 418; }
		location /install.php { return 418; }
		location /admin { return 418; }

		# Error pages
		error_page 404 /404/; location = /404/ { }
		error_page 418 /418/; location = /418/ { }
		error_page 500 /500/; location = /500/ { }
		error_page 502 /502/; location = /502/ { }
		error_page 503 /503/; location = /503/ { }
		error_page 504 /504/; location = /504/ { }
	}

}
