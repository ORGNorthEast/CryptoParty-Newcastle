# nginx Configuration

# Made public for anyone to copy/modify and learn from.
# If you spot any misconfiguration in this file - or anything you think I could be
# doing better - please let me know at: alex@alexhaydock.co.uk. Thanks.

user                                    nginx; # This user is named 'nginx' on Red Hat family distributions like CentOS and 'www-data' on Debian-based distributions.
worker_processes			1;

error_log				/var/log/nginx/error.log warn;
pid					/var/run/nginx.pid; # Set for CentOS. Probably in a different place on Debian.

events {
	worker_connections		1024; # Number of connections per worker process
}

http {
	# Keep access logs, but anonymise IPs
	map $remote_addr $ip_anonym1 { default 0.0.0; "~(?P<ip>(\d+)\.(\d+)\.(\d+))\.\d+" $ip; "~(?P<ip>[^:]+:[^:]+):" $ip; } # Grab part of the IP we want to have in the log
	map $remote_addr $ip_anonym2 { default .0; "~(?P<ip>(\d+)\.(\d+)\.(\d+))\.\d+" .0; "~(?P<ip>[^:]+:[^:]+):" ::; } # Return the part that symbolises the anonymised part
	map $ip_anonym1$ip_anonym2 $ip_anonymized { default 0.0.0.0; "~(?P<ip>.*)" $ip; } # Map them back together again
	log_format anonymised '$ip_anonymized - $remote_user [$time_local] "$request" $status $body_bytes_sent "$http_referer" "$http_user_agent"'; # Define the IP-'anonymised' logging format
	access_log /var/log/nginx/access.log anonymised; # Use IP-'anonymised' log format for the access log

	# Timeouts to ensure we do not keep connections open longer then necessary to reduce resource usage and deny Slowloris type attacks.
	client_body_timeout		4s; # maximum time between packets the client can pause when sending nginx any data
	client_header_timeout		4s; # maximum time the client has to send the entire header to nginx
	keepalive_timeout		75s; # timeout which a single keep-alive client connection will stay open
	send_timeout			24s; # maximum time between packets nginx is allowed to pause when sending the client data
#	spdy_keepalive_timeout		120s; # inactivity timeout after which the SPDY connection is closed
#	spdy_recv_timeout		4s; # timeout if nginx is currently expecting data from the client but nothing arrives

	# Various options
	charset				utf-8;
	default_type			application/octet-stream;
	ignore_invalid_headers		on;
	include				/etc/nginx/mime.types;
	index				index.html.en index.html; # Ensure that index.html.en is added to support the structure used in the TorProject mirror site
	keepalive_requests		50;  # Number of requests per connection (does not affect SPDY)
	keepalive_disable		none; # Allow all browsers to use keepalive connections
	max_ranges			1; # Only allow a single range header - for resumed downloads, and to stop large range header DoS attacks
	open_file_cache			max=1000 inactive=2h;
	open_file_cache_errors		on;
	open_file_cache_min_uses	1;
	open_file_cache_valid		1h;
	output_buffers			1 512; # Use one 512k chunk output buffer (only if sendfile is off)
	read_ahead			512K; # Kernel read head set to the output_buffers
	recursive_error_pages		on;
	reset_timedout_connection	on; # Reset timed out connections to free RAM
	sendfile			on;  # On for decent direct disk I/O
	server_tokens			off; # Version number in error pages
	server_name_in_redirect		off; # If off, nginx will use the requested Host header
	source_charset			utf-8; # Same value as "charset"
	tcp_nodelay			on; # Nagle buffering algorithm, used for keepalive only
	tcp_nopush			off;

	# Compression Options
	gzip				on;
	gzip_buffers			4 32k; # Set the buffer size of gzip, 4 32k is good enough for almost everybody. (Well, according to the tutorial I copied this line from...)
	gzip_proxied			any; # Allows compressed responses for any request even from proxies
	gzip_types			text/html
					text/css
					text/xml
					application/javascript
					application/atom+xml
					application/rss+xml
					text/plain
					application/font-woff
					application/json
					application/pdf
					application/x-x509-ca-cert
					application/xhtml+xml
					application/xspf+xml; # Here I just copied in all of the MIME types that looked compressible from /etc/nginx/mime.types (leaving out ones I will clearly never use)
	gzip_vary			on; # Enables response header of "Vary: Accept-Encoding

	# SSL options
	ssl_prefer_server_ciphers	on; # Ensure that my cipher preference list is used and not the client's
	ssl_session_cache		shared:SSL:5m; # Allow reuse of sessions so client doesn't need full handshake for each request. (https://vincent.bernat.im/en/blog/2011-ssl-session-reuse-rfc5077.html)
	ssl_session_timeout		5m; # But also timeout sessions after 5min to ensure forward secrecy.
	ssl_session_tickets		off;
#	ssl_stapling			on; # Must be disabled when using BoringSSL. (https://www.imperialviolet.org/2014/04/19/revchecking.html)
#	ssl_stapling_verify		on; # Must be disabled when using BoringSSL. (https://www.imperialviolet.org/2014/04/19/revchecking.html)

	# Redirect all CryptoParty HTTP requests to HTTPS
	server {
		listen			80; # listen on HTTP port for ipv4
#		listen			[::]:80; # listen on HTTP port for ipv6
		server_name		cryptopartynewcastle.org www.cryptopartynewcastle.org;

		rewrite			^ https://cryptopartynewcastle.org$request_uri? permanent;
	}

	# Redirect all CryptoParty Forum HTTP requests to HTTPS
	server {
		listen			80; # listen on HTTP port for ipv4
#		listen			[::]:80; # listen on HTTP port for ipv6
		server_name		forum.cryptopartynewcastle.org;

		rewrite			^ https://forum.cryptopartynewcastle.org$request_uri? permanent;
	}

	# Redirect all of my site HTTP requests to HTTPS
	server {
		listen			80; # listen on HTTP port for ipv4
#		listen			[::]:80; # listen on HTTP port for ipv6
		server_name		alexhaydock.co.uk www.alexhaydock.co.uk test.alexhaydock.co.uk;

		rewrite			^ https://alexhaydock.co.uk$request_uri? permanent;
	}

	# CryptoParty main site HTTPS Block
	server {
		listen			443 ssl http2; # Listen on SSL port for IPv4 with HTTP/2
#		listen			[::]:443 ssl http2; # Listen on SSL port for IPv6 with HTTP/2
		server_name		cryptopartynewcastle.org www.cryptopartynewcastle.org;
		root			/usr/share/nginx/html;
		ssl			on;

		# Redirect to the current thread about the next cryptoparty
		return			301 https://forum.cryptopartynewcastle.org/;

		# Manage standard headers
		add_header		Strict-Transport-Security "max-age=63072000; includeSubDomains; preload"; # Enable HSTS with a 2-year timeout
		add_header		X-Frame-Options "DENY"; # Disallow the site from being loaded in an IFRAME. Works to prevent clickjacking attempts
		add_header		X-Content-Type-Options nosniff;
		add_header		X-XSS-Protection "1; mode=block";
		add_header		Cache-Control "public";
		add_header		Referrer-Policy "strict-origin-when-cross-origin"; # Only supported from Firefox 52+, but we can now control referrer behaviour with a HTTP header

		# Manage CSP (http://www.html5rocks.com/en/tutorials/security/content-security-policy/)
		add_header		Content-Security-Policy "frame-ancestors 'none'; default-src 'self'; report-uri https://alexhaydock.report-uri.io/r/default/csp/enforce;";

                # Enable HTTP Public Key Pinning header (Here be demons!)
                ## Pin1 is for the CA cert of 'Let's Encrypt Authority X3', and Pin2 is for 'Gandi Standard SSL CA 2'. Maximum pin age is set to 60 days.
                ## I'm pinning CA certs here instead of my leaf cert because the leaf is regenerated every 90 days with LetsEncrypt and this could end up becoming a huge pain.
                ## At least with these pins it means that no weird CAs can go issuing certs for my domain and only LetsEncrypt/Gandi can do it.
		## This setup means that if LetsEncrypt disappears or I screw up somehow, I can at least go and buy a Gandi cert to get myself out of the mess.
                ## To avoid needing to extract certs and hash them with OpenSSL, remember that SSLLabs' testing tool helpfully shows the required sha256 hashes for pasting straight into this pinning line.
		## This line uses 'always' to ensure that Nginx will always send this header, regardless of the response code.
                add_header public-key-pins 'pin-sha256="YLh1dUR9y6Kja30RrAn7JKnbQG/uEtLMkBgFF2Fuihg="; pin-sha256="WGJkyYjx1QMdMe0UqlyOKXtydPDVrk7sl2fV+nNm1r4="; max-age=5184000; includeSubDomains; report-uri="https://alexhaydock.report-uri.io/r/default/hpkp/enforce"' always;

		# Site now uses LetsEncrypt as its default CA
		## Generate new 384-bit ECDSA cert (better than using a 4096-bit RSA cert because it forces us to use ECDHE) with the instructions at:
		##    https://github.com/ORGNorthEast/CryptoParty-Newcastle/tree/master/cryptopartynewcastle.org/LetsEncrypt/
		ssl_certificate		/usr/share/nginx/keys/cryptopartynewcastle.org/ecdsa-chain.pem;
		ssl_certificate_key	/usr/share/nginx/keys/cryptopartynewcastle.org/privkey-p384.pem;

		# Enable only highest-strength protocol(s)
		ssl_protocols		TLSv1.2; # Don't bother supporting TLS v1.0 and v1.1

		# Enable only highest strength ECDSA ciphers (Google Chrome's preferred order with 128bit before 256bit because it's faster and less susceptible to timing attacks)
		# ChaCha is now also preferred because of attacks on GCM detailed here: https://www.cryptologie.net/article/361/nonce-disrespecting-adversaries-practical-forgery-attacks-on-gcm-in-tls/	
		##ssl_ciphers		'ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384'; # OpenSSL (Disabled)
		ssl_ciphers		[ECDHE-ECDSA-CHACHA20-POLY1305]:[ECDHE-ECDSA-AES128-GCM-SHA256]:[ECDHE-ECDSA-AES256-GCM-SHA384]; # BoringSSL (https://github.com/ajhaydock/BoringNginx)

		# Specify a curve to use for the Elliptic Curve Diffie-Hellman Exchange (ECDHE) ciphers
		## This is set to 'auto' currently, which will pick X25519 (yay!) on Chromium 50+, but for other browsers I think it still defaults to
		## a secp256r1 256-bit curve. The 384-bit one would be better, but forcing secp384r1 seems to break the server from starting up at all.
		ssl_ecdh_curve		auto;

		# Main location block
		location / {
		}

		# Favicon
		location /favicon.ico {
			# This means that instead of forwarding requests for the favicon
			# to the proxy, it will look in the location specified in the root
			# directive above. This is where I have saved it.
		}

		location /.well-known {
			# LetsEncrypt client uses this directory to serve some files during the certificate generation process to prove we own the domain
			# This directive ensures that requests for this dir are served by Nginx itself and aren't passed back to any PHP processor or other reverse proxy
			root			/usr/share/nginx/letsencrypt;
		}

		# Other special location blocks
		location ~ \.htaccess { return 404; }
		location /.git { return 404; }
		location /wp-admin { return 404; }
		location /wp-login { return 404; }
		location /install.php { return 404; }
		location /admin { return 404; }
	}

	# CryptoParty Forum HTTPS Block
	server {
		listen			443 ssl http2; # Listen on SSL port for IPv4 with HTTP/2
#		listen			[::]:443 ssl http2; # Listen on SSL port for IPv6 with HTTP/2
		server_name		forum.cryptopartynewcastle.org;
		root			/usr/share/nginx/html;
		ssl			on;

		# Manage standard headers
		add_header		Strict-Transport-Security "max-age=63072000; includeSubDomains; preload"; # Enable HSTS with a 2-year timeout
		add_header		X-Frame-Options "SAMEORIGIN";
		add_header		X-Content-Type-Options nosniff;
		add_header		X-XSS-Protection "1; mode=block";
		add_header		Cache-Control "public";
		add_header		Referrer-Policy "strict-origin-when-cross-origin"; # Only supported from Firefox 52+, but we can now control referrer behaviour with a HTTP header

		# Manage CSP (http://www.html5rocks.com/en/tutorials/security/content-security-policy/)
		## The img-src directive here allows loading images from any domain, but only if using HTTPS. This is mostly to allow the use of the "one box" that generates a link preview in forum posts.
		add_header		Content-Security-Policy "frame-ancestors 'none'; default-src 'self'; script-src 'unsafe-inline' 'unsafe-eval' forum.cryptopartynewcastle.org; style-src 'unsafe-inline' forum.cryptopartynewcastle.org; img-src https:; object-src 'none'; report-uri https://alexhaydock.report-uri.io/r/default/csp/enforce;";

                # Enable HTTP Public Key Pinning header (Here be demons!)
                ## See note in section above.
                add_header public-key-pins 'pin-sha256="YLh1dUR9y6Kja30RrAn7JKnbQG/uEtLMkBgFF2Fuihg="; pin-sha256="WGJkyYjx1QMdMe0UqlyOKXtydPDVrk7sl2fV+nNm1r4="; max-age=5184000; includeSubDomains; report-uri="https://alexhaydock.report-uri.io/r/default/hpkp/enforce"' always;

		# Site now uses LetsEncrypt as its default CA
		## Generate new 384-bit ECDSA cert (better than using a 4096-bit RSA cert because it forces us to use ECDHE) with the instructions at:
		##    https://github.com/ORGNorthEast/CryptoParty-Newcastle/tree/master/cryptopartynewcastle.org/LetsEncrypt/
		ssl_certificate		/usr/share/nginx/keys/cryptopartynewcastle.org/ecdsa-chain.pem;
		ssl_certificate_key	/usr/share/nginx/keys/cryptopartynewcastle.org/privkey-p384.pem;

		# Enable only highest-strength protocol(s)
		ssl_protocols		TLSv1.2; # Don't bother supporting TLS v1.0 and v1.1

		# Enable only highest strength ECDSA ciphers (Google Chrome's preferred order with 128bit before 256bit because it's faster and less susceptible to timing attacks)
		# ChaCha is now also preferred because of attacks on GCM detailed here: https://www.cryptologie.net/article/361/nonce-disrespecting-adversaries-practical-forgery-attacks-on-gcm-in-tls/	
		##ssl_ciphers		'ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384'; # OpenSSL (Disabled)
		ssl_ciphers		[ECDHE-ECDSA-CHACHA20-POLY1305]:[ECDHE-ECDSA-AES128-GCM-SHA256]:[ECDHE-ECDSA-AES256-GCM-SHA384]; # BoringSSL (https://github.com/ajhaydock/BoringNginx)

		# Specify a curve to use for the Elliptic Curve Diffie-Hellman Exchange (ECDHE) ciphers
		## This is set to 'auto' currently, which will pick X25519 (yay!) on Chromium 50+, but for other browsers I think it still defaults to
		## a secp256r1 256-bit curve. The 384-bit one would be better, but forcing secp384r1 seems to break the server from starting up at all.
		ssl_ecdh_curve		auto;

		# Main forum location block
		location / {
			proxy_pass		http://172.16.16.50:8090/;
			proxy_read_timeout	90;
			proxy_redirect		http://172.16.16.50:8090/ https://forum.cryptopartynewcastle.org/;

			# These directives define the headers that will be passed from the CLIENT to the SERVER.
			proxy_set_header	X-Forwarded-Ssl on;
			proxy_set_header	Upgrade $http_upgrade;
			proxy_set_header	Connection "upgrade";
			proxy_set_header	Host $http_host;
			proxy_set_header	X-Real-IP $remote_addr;
			proxy_set_header	X-Forwarded-For $proxy_add_x_forwarded_for;
			proxy_set_header	X-Forwarded-Proto $scheme;

			# These directives define the headers that will be ignored and not passed from SERVER to CLIENT
			# we do this because Discourse tries to set some of these itself, but we want to set them manually
			# for greater control. These are set above using the add_header directives.
			proxy_hide_header	Content-Security-Policy;
			proxy_hide_header	X-Content-Type-Options;
			proxy_hide_header	X-Frame-Options;
			proxy_hide_header	X-XSS-Protection;
		}


		# Favicon
		location /favicon.ico {
			# This means that instead of forwarding requests for the favicon
			# to the proxy, it will look in the location specified in the root
			# directive above. This is where I have saved it.
		}

		location /.well-known {
			# LetsEncrypt client uses this directory to serve some files during the certificate generation process to prove we own the domain
			# This directive ensures that requests for this dir are served by Nginx itself and aren't passed back to any PHP processor or other reverse proxy
			root			/usr/share/nginx/letsencrypt;
		}

		# Other special location blocks
		location ~ \.htaccess { return 404; }
		location /.git { return 404; }
		location /wp-admin { return 404; }
		location /wp-login { return 404; }
		location /install.php { return 404; }
	}

	# My site HTTPS block
	server {
		listen			443 ssl http2; # Listen on SSL port for IPv4 with HTTP/2
#		listen			[::]:443 ssl http2; # Listen on SSL port for IPv6 with HTTP/2
		server_name		alexhaydock.co.uk www.alexhaydock.co.uk test.alexhaydock.co.uk;
		root			/usr/share/nginx/html;
		ssl			on;

		# Manage standard headers
		add_header		Strict-Transport-Security "max-age=63072000; includeSubDomains; preload"; # Enable HSTS with a 2-year timeout
		add_header		X-Frame-Options "DENY"; # Disallow the site from being loaded in an IFRAME. Being deprecated in favour of CSP's frame-ancestors directive: https://appsec-labs.com/portal/anti-clickjacking/
		add_header		X-Content-Type-Options nosniff;
		add_header		X-XSS-Protection "1; mode=block";
		add_header		Cache-Control "public";
		add_header		Referrer-Policy "no-referrer"; # Only supported from Firefox 52+, but we can now control referrer behaviour with a HTTP header

		# Manage CSP header (https://wiki.mozilla.org/Security/CSP/Specification)
		## This policy will block basically all scripts, plugins, child frames (YouTube embeds etc.) and will need reviewing if I ever start using those but, for now, this is going to be pretty secure.
		add_header		Content-Security-Policy "frame-ancestors 'none'; default-src 'none'; font-src 'self'; img-src 'self'; media-src 'self'; style-src 'self'; report-uri https://alexhaydock.report-uri.io/r/default/csp/enforce;";

                # Enable HTTP Public Key Pinning header (Here be demons!)
                ## See note in section above.
                add_header public-key-pins 'pin-sha256="YLh1dUR9y6Kja30RrAn7JKnbQG/uEtLMkBgFF2Fuihg="; pin-sha256="WGJkyYjx1QMdMe0UqlyOKXtydPDVrk7sl2fV+nNm1r4="; max-age=5184000; includeSubDomains; report-uri="https://alexhaydock.report-uri.io/r/default/hpkp/enforce"' always;

		# Site now uses LetsEncrypt as its default CA
		## Generate new 384-bit ECDSA cert (better than using a 4096-bit RSA cert because it forces us to use ECDHE) with the instructions at:
		##    https://github.com/ORGNorthEast/CryptoParty-Newcastle/tree/master/cryptopartynewcastle.org/LetsEncrypt/
		ssl_certificate		/usr/share/nginx/keys/alexhaydock.co.uk/ecdsa-chain.pem;
		ssl_certificate_key	/usr/share/nginx/keys/alexhaydock.co.uk/privkey-p384.pem;

		# Enable only highest-strength protocol(s)
		ssl_protocols		TLSv1.2; # Don't bother supporting TLS v1.0 and v1.1

		# Enable only highest strength ECDSA ciphers (Google Chrome's preferred order with 128bit before 256bit because it's faster and less susceptible to timing attacks)
		# ChaCha is now also preferred because of attacks on GCM detailed here: https://www.cryptologie.net/article/361/nonce-disrespecting-adversaries-practical-forgery-attacks-on-gcm-in-tls/	
		##ssl_ciphers		'ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384'; # OpenSSL (Disabled)
		ssl_ciphers		[ECDHE-ECDSA-CHACHA20-POLY1305]:[ECDHE-ECDSA-AES128-GCM-SHA256]:[ECDHE-ECDSA-AES256-GCM-SHA384]; # BoringSSL (https://github.com/ajhaydock/BoringNginx)

		# Specify a curve to use for the Elliptic Curve Diffie-Hellman Exchange (ECDHE) ciphers
		## This is set to 'auto' currently, which will pick X25519 (yay!) on Chromium 50+, but for other browsers I think it still defaults to
		## a secp256r1 256-bit curve. The 384-bit one would be better, but forcing secp384r1 seems to break the server from starting up at all.
		ssl_ecdh_curve		auto;

		# Main forum location block
		location / {
			proxy_pass		http://172.16.16.30/;
			proxy_redirect		http://172.16.16.30/ https://alexhaydock.co.uk/;
			proxy_read_timeout	90;

			# These directives define the headers that will be passed from the CLIENT to the SERVER.
			proxy_set_header	X-Forwarded-Ssl on;
			proxy_set_header	Upgrade $http_upgrade;
			proxy_set_header	Connection "upgrade";
			proxy_set_header	Host $http_host;
			proxy_set_header	X-Real-IP $remote_addr;
			proxy_set_header	X-Forwarded-For $proxy_add_x_forwarded_for;
			proxy_set_header	X-Forwarded-Proto $scheme;

			# These directives define the headers that will be ignored and not passed from SERVER to CLIENT
			# we do this because Discourse tries to set some of these itself, but we want to set them manually
			# for greater control. These are set above using the add_header directives.
			proxy_hide_header	Content-Security-Policy;
			proxy_hide_header	X-Content-Type-Options;
			proxy_hide_header	X-Frame-Options;
			proxy_hide_header	X-XSS-Protection;
		}

		# TorProject mirror location block
		location /torproject/ {
			root			/usr/share/nginx/html; # The /torproject/ from the "location" line above gets appended to this path.
			autoindex		on; # Turn on autoindexing for TorProject dir so that users can browse download dirs
		}

		location /.well-known {
			# LetsEncrypt client uses this directory to serve some files during the certificate generation process to prove we own the domain
			# This directive ensures that requests for this dir are served by Nginx itself and aren't passed back to any PHP processor or other reverse proxy
			root			/usr/share/nginx/letsencrypt;
		}

		# Other special location blocks
		location ~ \.htaccess { return 404; }
		location /.git { return 404; }
		location /wp-admin { return 404; }
		location /wp-login { return 404; }
		location /install.php { return 404; }
	}
}
